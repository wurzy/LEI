POR IMPLEMENTAR:

- separar os moustaches que dão tipos diferentes para moustaches diferentes
- lista de erros para apresentar de maneira user-friendly no vue -> keywords reservadas do Strapi

--- como fica o modelo se puser uma cena básica como coleção?

--------------------------------------------------------


MAP:
- map(function(x) {...})
- map(x => {...})

- modelos de repeats com functionals

<!LANGUAGE pt>
{
  colecao: [
	'repeat(3)': {
	  	range: ['repeat(3)': 1],
	  	range2: ['repeat(3)': 1].map(x => { return x*2 }),
	  	range3: ['repeat(3)': 1].filter(x => { return x>2 }),
	  	range4: ['repeat(3)': 1].reduce(function(a,x) { return a+x })
    }
  ].map(x => { return x.range2 })
}

<!LANGUAGE pt>
{
  colecao: [
	'repeat(3)': {
	  	map1: range(5).map(value => { return value+1 }),
	  	map2: range(5).map((value) => { return value+1 }),
	  	map3: [0,1,2,3,4].map((value, index) => { return [0,1,2,3,4][index]+1 }),
	  	map4: range(5).map((value, index, array) => { return array[index]+1 }),
          
	  	map5: range(5).map(function(value) { return value+1 }),
	  	map6: range(5).map(function(value) { return value+1 }),
	  	map7: [0,1,2,3,4].map(function(value, index) { return [0,1,2,3,4][index]+1 }),
	  	map8: range(5).map(function(value, index, array) { return array[index]+1 }),
    
	  	filter1: range(5).filter(value => { return value>2 }),
	  	filter2: range(5).filter((value) => { return value>2 }),
	  	filter3: [0,1,2,3,4].filter((value, index) => { return [0,1,2,3,4][index]>2 }),
	  	filter4: range(5).filter((value, index, array) => { return array[index]>2 }),
          
	  	filter5: range(5).filter(function(value) { return value>2 }),
	  	filter6: range(5).filter(function(value) { return value>2 }),
	  	filter7: [0,1,2,3,4].filter(function(value, index) { return [0,1,2,3,4][index]>2 }),
	  	filter8: range(5).filter(function(value, index, array) { return array[index]>2 }),
    
	  	reduce1: range(5).reduce((accum, value) => { return accum + value }),
	  	reduce2: [0,1,2,3,4].reduce((accum, value, index) => { return accum + [0,1,2,3,4][index] }),
	  	reduce3: range(5).reduce((accum, value, index, array) => { return accum + array[index] }),
          
	  	reduce4: range(5).reduce(function(accum, value) { return accum + value }),
	  	reduce5: [0,1,2,3,4].reduce(function(accum, value, index) { return accum + [0,1,2,3,4][index] }),
	  	reduce6: range(5).reduce(function(accum, value, index, array) { return accum + array[index] }),

		mix: range(5).map((value) => { return value+3 }).filter(x => { return x >= 10}).map(x => { return x*2 }).reduce((a,c) => { return a+c })
    
    }
  ]
}



PROGRESSO DESTA SEMANA:

- map/filter/reduce
	- função explícita ou anónima
	- todos os argumentos possíveis em JS
	- encadeamento











- repeats sem repetir elementos (para 1 moustache)
- dataset memoryBook
- conversão JSON para Strapi
- referenciação local em interpolação
- protótipo inicial do map e filter







































- Autos
- dataset de PRC
- if else if else / or / at_least
- funções anónimas
- referência local em funções e ifs
- referência local em moustaches


- rotas para os datasets de suporte

























- XML
- gramática bullet-proof (Strapi)
- funcionalidades novas dos PPD e Autos
	- index(offset)
	- .string()
	- integer com x número de algarismos (padding de zeros à esquerda)
	- dataset pt_entities -> sigla ou designacao
	- caracteres não-ASCII em nomes de atributos
	- dar moustaches como argumentos ao random -> generalizar os args para qualquer coisa
	- atributo on condition
	- atributos mutuamente exclusivos
	- pelo menos x de um conjunto de atributos
	- repeat_unique com moustaches (precário)































- aceitar vários repeats seguidos (retornar uma lista com várias coleções diferentes)
- moustaches para gerar datas aleatórias
- recursividade infinita no processamento de moustaches (permitir moustaches em qualquer objeto e array)
- moustaches de acesso a datasets
- sistema para definir a linguagem dos datasets
	- moustaches sempre em inglês
	- linha inicial no texto a ser processado que indica pt/en
	- datasets pt e en para cada coleção
- interpolação de strings com moustaches
	- entre plicas pode vir:
		- string vazia: ''
		- string: 'bom dia'
		- moustaches: '{{index()}}'
		- interpolação: 'texto - {{pt_parish()}}, {{pt_county()}}, {{pt_district()}}'

- permitir qualquer tipo em missing/having
- reestruturar o programa para o formato a la json-server que discutimos com o professor
- otimizar a estrutura da gramática
- versão inicial das propriedades com código
- suporte pt/en dos datasets

- range a la Python
- datasets pt/en
- funções
- randoms com garantia de não repetir elementos
- modelo de strapi com a filipa